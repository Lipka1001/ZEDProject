---
title: "Protein Data Bank"
author: "Katarzyna Lipowska"
date: '`r format(Sys.Date(), "%d %B %Y")`'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, cache.lazy = TRUE, cache = TRUE)
```
##Spis treści
1. [Streszczenie](#streszczenie)
2. [Statystyki](#statystyki)
3. [Korelacja](#korelacja)
4. [Top 50 klas](#top-50-klas)
5. [Wykresy rozkładow liczby atomow i elektronow](#wykresy-rozkladow-liczby-atomow-i-elektronow)
6. [Niezgodnosc liczby atomow i elektronow](#niezgodnosc-liczby-atomow-i-elektronow)
7. [Rozklad kolumn part_01](#rozklad-kolumn-part_01)
8. [Regresja](#regresja)
9. [Klasyfikator](#klasyfikator)


## Streszczenie

Raport dotyczy analizy danych krystalograficznych pochodzących z bazy Protein Data Bank (PDB). 

Duża liczba atrybutów w zbiorze mogła spowodować nieczytelność korelacji, dlatego należało zawęzić zbiór do wybranych kolumn.

Bardzo ważny okazał się wybór atrybutów wykorzystywanych w regresji i klasyfikacji - zależała od niego poprawność predykcji.

Jedną z obserwacji jest fakt, że pozycje w rankingu klas z największą niezgodnością liczby atomów są podobne do pozycji w rankingu klas z największą niezgodnością liczby elektronów.

Można zauważyć, że wykorzystanie uczenia maszynowego może pomóc biologom w stwierdzeniu jakie cząsteczki mogą się kryć w niewymodelowanych fragmentach map intensywności.

Podstawową trudnością podczas wykonywania projektu była nieznajomość dziedziny, której dotyczyły dane. Osoba posiadająca odpowiednią wiedzę biologiczną z pewnością wyciągnęłaby z analizy więcej wniosków i zauważyła dodatkowe zależnosci.

```{r libraries, message=FALSE}
library(dplyr)
library(ggplot2)
library(data.table)
library(knitr)
library(plotly)
library(DT)
library(corrplot)
library(reshape2)
library(caret)
library(randomForest)

prettyTable <- function(table_df, round_columns=numeric(), round_digits=2) {
DT::datatable(table_df, style="bootstrap", rownames = TRUE, options=list(dom='tp')) %>%formatRound(round_columns, round_digits)}
  
prettyTableWithoutPagination <- function(table_df, round_columns=numeric(), round_digits=2) {
DT::datatable(table_df, style="bootstrap", rownames = TRUE, options=list(dom='t')) %>%formatRound(round_columns, round_digits)
}
```

```{r setseed}
set.seed(20)
```

```{r import, include=FALSE}
prot_data <- fread("all_summary.csv", nrows=10000)
#prot_data <- head(prot_data,10000)
```

```{r filter}
prot_data2 <- filter(prot_data, !res_name %in% c("UNK", "UNX", "UNL", "DUM", "N", "BLOB", "ALA", "ARG", "ASN", "ASP", "CYS", "GLN", "GLU", "GLY", "HIS", "ILE", "LEU", "LYS", "MET", "MSE", "PHE", "PRO", "SEC", "SER", "THR", "TRP", "TYR", "VAL", "DA", "DG", "DT", "DC", "DU", "A", "G", "T", "C", "U", "HOH", "H20", "WAT"))
```

```{r na}
prot_data2 <- filter(prot_data2, !is.na(res_name))
prot_data2 <- prot_data2[!sapply(prot_data2, function(x)all(is.na(x)))]
```

##Statystyki
Analizowany zbór danych zawiera `r nrow(prot_data2)` wierszy i `r ncol(prot_data2)` kolumn. Poniżej zamieszczono najważniejsze statystyki. Statystyki dotyczą tylko danych typu numeric lub integer.
```{r stats}
my_summary <- data.frame(summary(prot_data2))
my_summary <- filter(my_summary, !is.na(Freq))

num <- prot_data2[sapply(prot_data2, function(x)(is.numeric(x)|is.integer(x)))]

num_stats <- t(sapply(num, function(x){list(min(x, na.rm=TRUE),max(x, na.rm=TRUE),mean(x, na.rm=TRUE),median(x,na.rm=TRUE),sum(is.na(x)))}))
colnames(num_stats) <- c("Min", "Max", "Mean", "Median", "Number of NAs")
prettyTable(num_stats)
```


```{r filter_50}
p <- prot_data2 %>% group_by(res_name) %>% count(res_name) %>% arrange(desc(n)) %>% head(50)
prot_data3 <- filter(prot_data2, res_name %in% c(p$res_name))
```

##Korelacja
Analizowany zbiór danych posiada dużą liczbę atrybutów. Korelacja między wszystkimi atrybutami byłaby nieczytelna graficznie i trudna do analizy. Dlatego korelacja została przedstawiona tylko dla kolumn rozpoczynających się od "part_0". Kolumny te reprezentują atrybuty różnych poziomów odcięcia intensywności. 
```{r Korelacja}
part_col<-prot_data3 %>% select(starts_with("part_0"))
part_col<-part_col[complete.cases(part_col),]
part_col_cor<-cor(part_col)
get_triangle<-function(cormat){
    cormat[upper.tri(cormat)] <- NA
    return(cormat)
}
part_col_cor<-get_triangle(part_col_cor)
part_col_cor_m <- melt(part_col_cor)
cor_plot<-ggplot(data = part_col_cor_m, aes(x=Var1, y=Var2)) + geom_tile(aes(fill = value)) +
theme(axis.title.x=element_blank(), 
      axis.text.x=element_blank(),
      axis.ticks.x=element_blank(),
      axis.title.y=element_blank(),
      axis.text.y=element_blank(),
      axis.ticks.y=element_blank()) +scale_fill_continuous(na.value="white")
ggplotly(cor_plot)
```

##Top 50 klas
Poniższa tabela przedstawia 50 najczęściej występujących nazw ligandu (res_name) w zbiorze danych.
```{r Top50}
prettyTable(p)
```

##Wykresy rozkladow liczby atomow i elektronow
###a) rozkład liczby atomów
```{r rozkład_atomow}
histogram1 <- ggplot(prot_data3, aes(x=local_res_atom_non_h_count)) + geom_histogram(binwidth=1, fill="white", colour="black")
histogram1
```

###b) rozkład liczby elektronów
```{r rozkład_elektronow}
histogram2 <- ggplot(prot_data3, aes(x=local_res_atom_non_h_electron_sum)) + geom_histogram(binwidth=6, fill="white", colour="black")
histogram2
```

##Niezgodnosc liczby atomow i elektronow
Dla danych pogrupowanych po atrybucie res_name obliczono średnią niezgodność liczby atomów i elektronów. Klasy z największą niezgodnością przedstawiono w tabeli poniżej.

###a) klasy z największą nizgodnością liczby atomów
```{r diff_a}
atom <- prot_data3 %>% mutate(diff=abs(local_res_atom_non_h_count - dict_atom_non_h_count)) %>% group_by(res_name) %>% summarize(group_diff=mean(diff)) %>% arrange(desc(group_diff)) %>% head(10)
prettyTableWithoutPagination (atom)
```

###b) klasy z najwiekszą niezgodnościa liczby elektronów
```{r diff_e}
electron <- prot_data3 %>% mutate(diff=abs(local_res_atom_non_h_electron_sum - dict_atom_non_h_electron_sum)) %>% group_by(res_name) %>% summarize(group_diff=mean(diff)) %>% arrange(desc(group_diff)) %>% head(10)
prettyTableWithoutPagination (electron)
```

##Rozklad kolumn part_01
Poniższe wykresy przedstawiają rozkład wartości kolumn o nazwach zaczynających się od "part_01". Na wykresach zaznaczono średnią wartość.
```{r part_01}
part_01_col<-prot_data3 %>% select(starts_with("part_01"))
for(i in 1:ncol(part_01_col)){
    part_col <- part_01_col[[i]]
    part_col_1 <- na.omit(part_col)
    part_col_mean <- mean(part_01_col[[i]], na.rm = TRUE)
    plot <- ggplot(part_01_col, aes(x=part_col)) + geom_density(fill='white')+ ggtitle(names( part_01_col[i])) + geom_rug(sides="b", color="navy", size = 1, aes(x=part_col_mean, y=0)) + xlab(names(part_01_col[i])) + geom_text(aes(label=signif(part_col_mean, digits = 3), x=part_col_mean, y=0), hjust=0.4, vjust=-0.4, color="navy")
    
    print(plot)
}
```

##Regresja
W tej sekcji sprawdzono, za pomoca regresji liniowej, czy na podstawie wartości innych kolumn można przewidzieć liczbę elektronów i atomów. Dla regresji wybrane zostały następujące atrybuty: local_volume, local_electrons, local_mean, local_std, local_min, local_max, local_skewness, resolution.
```{r Regresja}
RegDataAtom <- prot_data3 %>% select(local_volume, local_electrons, local_mean, local_std, local_min, local_max, local_skewness, resolution, local_res_atom_non_h_count)
RegDataAtom <- RegDataAtom[complete.cases(RegDataAtom),]
RegAtom <- train(local_res_atom_non_h_count~., RegDataAtom, method="lm")

RegDataElectron <- prot_data3 %>% select(local_volume, local_electrons, local_mean, local_std, local_min, local_max, local_skewness, resolution, local_res_atom_non_h_electron_sum)
RegDataElectron  <- RegDataElectron [complete.cases(RegDataElectron ),]
RegElectron  <- train(local_res_atom_non_h_electron_sum~., RegDataElectron , method="lm")
```

Dla atomów wartość miary RMSE wynosła `r RegAtom$results$RMSE`, a wartość miary R^2 `r RegAtom$results$Rsquared`.
Dla elektronów wartość miary RMSE wyniosła `r RegElectron$results$RMSE`, a wartość miary R^2 `r RegElectron$results$Rsquared`.

##Klasyfikator
W tej sekcji stworzono klasyfikator, który przewiduje wartość res_name na podstawie wartości w innych kolumnach. Jako metodę klasyfikacji wybrano Random Forest. Do klasyfikacji wybrano atrybuty: FoFc_mean, FoFc_std, FoFc_square_std, FoFc_min, FoFc_max, resolution.
```{r Klasyfikator}
ClassData <- prot_data3 %>% select(local_volume, local_electrons, local_mean, local_std, local_min, local_max, local_skewness,FoFc_mean, FoFc_std, FoFc_square_std, FoFc_min, FoFc_max, resolution, res_name)
ClassData <- ClassData[complete.cases(ClassData),]
ClassData$res_name <- factor(ClassData$res_name, labels=c(1:length(table(ClassData$res_name))))
ClassDataTrain <- createDataPartition(ClassData$res_name, p=.7, list = FALSE)
Training <- ClassData[ClassDataTrain,]
Testing <- ClassData[-ClassDataTrain,]

ctrl <- trainControl(method = "repeatedcv", number = 2, repeats = 5)

ClassDataModel <- train(res_name~., data = Training, method="rf", tControl = ctrl, ntree = 30)
ClassDataPred <- predict(ClassDataModel, newdata = Testing)

matrix<-confusionMatrix(data=ClassDataPred, Testing$res_name)
overall_table <- matrix$overall

```

Miary jakości klasyfikatora wyniosły: Accuracy: `r overall_table[1]`, Kappa: `r overall_table[2]`.
